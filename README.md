# Проект поискового движка(SearchEngine).

- [Описание проекта](#описание-проекта)
  - [Принципы работы поискового движка](#принципы-работы-поискового-движка)
  - [Реализация принципов работы поискового движка](#реализация-принципов-работы-поискового-движка)
- [Описание стека используемых технологий](#описание-стека-используемых-технологий)
- [Тестирование](#тестирование)
- [Запуск проекта локально](#запуск-проекта-локально)



## Описание проекта
Поисковый движок - консольное приложение (исполняемый
файл, запускаемый на любом сервере или компьютере),
осуществляющее поиск и имеющее возможность настройки через файлы формата JSON.

### Принципы работы поискового движка:
1. В конфигурационном файле config.json перед запуском приложения задаются названия файлов, по которым движок будет осуществлять поиск.<br>
   Описание файла config.json:
```
{
"config": {
"name": "SkillboxSearchEngine",
"version": "0.1",
"max_responses": 5
},
"files": [
"../resources/file001.txt",
"../resources/file002.txt",
"../resources/file003.txt",
"../resources/file004.txt",
…
]
}
```
Описание полей файла config.json:

- config — общая информация, без которой приложение не запускается. Если это поле отсутствует, то при старте программа выбрасывает исключение и выводит в текстовую консоль ошибку: "config file is empty". Если отсутствует сам файл config.json, то будет выбрышено исключение и выведена ошибка: "config file is missing".
- name — поле с названием поискового движка.
  Информация из данного поля отображается при старте приложения.
- version - поле с номером версии поискового движка.
- max_responses — поле, определяющее максимальное количество ответов на один запрос.
- files - поле содержит пути к файлам, по которым необходимо осуществлять поиск. Если по указанному пути  файл не существует, то на экран выводится соответствующая ошибка, но выполнение программы не прекращается.

2. Пользователь задаёт запрос через файл с запросами requests.json.
   Он содержит наборы слов, по которым нужно найти документы.
```
{
"requests": [
"some words..",
"some words..",
"some words..",
"some words..",
…
]
}
```
3. Поисковый движок самостоятельно обходит все файлы и индексирует их так, чтобы потом по любому поисковому запросу находить наиболее релевантные документы.
4. Запрос трансформируется в список слов.
5. В индексе ищутся те документы, на которых встречаются все эти слова.
6. Результаты поиска ранжируются, сортируются и отдаются пользователю, максимальное количество возможных документов в ответе задаётся в конфигурационном файле.
7. В конце программа формирует файл answers.json, в который записывает результаты поиска.
   Пример описания файла answers.json:
```
{
"answers": {
"request001": {
"result": "true",
"relevance": {
"docid": 0, “rank” : 0.989,
"docid": 1, “rank” : 0.897,
"docid": 2, “rank” : 0.750,
"docid": 3, “rank” : 0.670,
"docid": 4, “rank” : 0.561
}
},
"request002": {
"result": "true",
"docid": 0, “rank” : 0.769
},
"request003": {
"result": "false"
}
}
}
```
Информация о полях файла answers.json:
- answers — базовое поле в этом файле, которое содержит ответы на запросы.
  request001 … 003 — идентификатор запроса, по которому сформирован ответ.
  Идентификатор запроса формируется автоматически по порядку, в котором
  находятся запросы в поле requests файла requests.json. Например:
  "requests": [<br>
  &nbsp; &nbsp; "some words..", для данной строки id запроса будет равен “request001”<br>
  &nbsp; &nbsp;  "some words..", для данной строки id запроса будет равен “request002”<br>
  &nbsp; &nbsp; "some words..", для данной строки id запроса будет равен “request003”<br>
  &nbsp; &nbsp; "some words..", для данной строки id запроса будет равен “request004”<br>
  &nbsp; &nbsp; …<br>
  ]
- result – результат поиска запроса. Если он принимает значение true, значит по
  данному запросу найден хотя бы один документ. Если результат имеет значение
  false, значит ни одного документа не найдено. Тогда других полей в ответе на
  этот запрос нет.
- relevance включается в файл answers.json, если на этот запрос удалось найти
  более одного документа.

Далее идут соответствия рейтинга ответа и названия id документа, в котором
осуществлялся поиск:

<Идентификатор документа>("docid") — идентификатор документа, в котором
найден ответ на запрос. Он формируется автоматически при индексации всех
документов исходя из порядка, в котором документы расположены в поле files в
файле config.json.<br>
Например, если в поле config.json поле files содержит:"files": [<br>
&nbsp; &nbsp; "../resources/file001.txt", для данного файла docid будет равен 0<br>
&nbsp; &nbsp; "../resources/file002.txt", для данного файла docid будет равен 1<br>
&nbsp; &nbsp; "../resources/file003.txt", для данного файла docid будет равен 2<br>
&nbsp; &nbsp; "../resources/file004.txt", для данного файла docid будет равен 3<br>
&nbsp; &nbsp;  … <br>
]

<ранг ответа>(“rank”) — ранг или поисковый рейтинг. Это число показывает,
насколько документ подходит для заданного запроса. В ответе id документов
располагаются в порядке уменьшения поискового рейтинга.


### Реализация принципов работы поискового движка
Для реализации принципов работы поискового движка созданы классы:<br>
ConverterJSON;<br>
InvertedIndex;<br>
SearchServer.


#### Класс ConverterJSON
Объект класса ConverterJSON работает с файлами config.json, answers.json и
requests.json, описанными выше.

Интерфейс класса ConverterJSON:

```
/**
* Класс для работы с JSON-файлами
*/
class ConverterJSON {
public:
    ConverterJSON() = default;

    /**
    * Метод получения содержимого файлов
    * @return Возвращает список с содержимым файлов перечисленных
    * в config.json
    */
    std::vector<std::string> GetTextDocuments();

    /**
    * Метод считывает поле max_responses для определения предельного
    * количества ответов на один запрос
    * @return
    */
    int GetResponsesLimit();

    /**
    * Метод получения запросов из файла requests.json
    * @return возвращает список запросов из файла requests.json
    */
    std::vector<std::string> GetRequests();

    /**
    * Положить в файл answers.json результаты поисковых запросов
    */
    void putAnswers(std::vector<std::vector<std::pair<int, float>>> answers);
}
```

#### Класс InvertedIndex
Объект класса InvertedIndex принимает текстовые блоки и формирует из них инвертированный индекс.<br>
Инвертированный индекс (inverted index) — структура
данных. В ней для каждого слова коллекции документов в соответствующем списке перечислены все документы в коллекции, в которых оно встретилось.<br>
Инвертированный индекс используется для поиска по текстам.

Интерфейс класса InvertedIndex и структура Entry:

```
struct Entry {
    size_t doc_id, count;
    // Данный оператор необходим для проведения тестовых сценариев
    bool operator ==(const Entry& other) const {
        return (doc_id == other.doc_id && count == other.count);
}
};


class InvertedIndex {
public:
    InvertedIndex() = default;
    /**
    * Обновить или заполнить базу документов, по которой будем совершать
    поиск
    * @param texts_input содержимое документов
    */
    void UpdateDocumentBase(std::vector<std::string> input_docs);
    /**
    * Метод определяет количество вхождений слова word в загруженной базе  документов
    * @param word слово, частоту вхождений которого необходимо определить
    * @return возвращает подготовленный список с частотой слов
    */

    std::vector<Entry> GetWordCount(const std::string& word);
private:
    std::vector<std::string> docs; // список содержимого документов
    std::map<std::string, std::vector<Entry>> freq_dictionary; // частотный
словарь
};
```

#### Класс SearchServer
Объект класс SearchServer определяет наиболее релевантные, соответствующие поисковому запросу документы.

Интерфейс класса SearchServer и структура RelativeIndex:

```
struct RelativeIndex{
    size_t doc_id;
    float rank;
    bool operator ==(const RelativeIndex& other) const {
        return (doc_id == other.doc_id && rank == other.rank);
}
};

class SearchServer {
public:
    /**
    * @param idx в конструктор класса передаётся ссылка на класс
    InvertedIndex,
    * чтобы SearchServer мог узнать частоту слов встречаемых в
    запросе
    */
    SearchServer(InvertedIndex& idx) : _index(idx){ };
    /**
    * Метод обработки поисковых запросов
    * @param queries_input поисковые запросы взятые из файла
    requests.json
    * @return возвращает отсортированный список релевантных ответов для
    заданных запросов
    */
    std::vector<std::vector<RelativeIndex>> search
        (const std::vector<std::string>& queries_input);
private:
    InvertedIndex _index;
};
```



## Тестирование
Подключена библиотека Google Test для проведения модульных тестов.<br>
Тесты расположены в папке tests (${CMAKE_SOURCE_DIR}/tests).<br>

Чтобы убедиться, что объект класса InvertedIndex правильно заполняет<br>
коллекцию freq_dicitonary, используется набор тестов test_invert_index.cpp<br>

Чтобы убедиться, что объект класса SearchServer правильно рассчитывает<br>
абсолютную и относительную релевантность, используется набор тестов test_search_server.cpp


## Описание стека используемых технологий

Кроссплатформенное средство автоматизации сборки программного обеспечения [CMake](https://cmake.org/).<br>
Библиотека [nlohmann/json](https://github.com/nlohmann/json?ysclid=mee218zckk492605789).<br>
Фреймворк для тестирования [GoogleTest(GTest)](https://github.com/google/googletest).

## Запуск проекта локально

CMAKE 3.17<br>
MinGW